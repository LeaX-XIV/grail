# Grail

## Compilation

	$ make

## Run

	$ ./grail <graph_file> <d> <query_file>

## Design

The program is implemented in the UNIX-like POSIX system.

We decided to parallelize the index creation and the query resolution as two different, unrelated parts.

For index creation, we generate `d` threads, each of which generates one layer of labels with a time complexity O(n + m). No synchronization primitives are needed during this phase, as every thread works on different portions of memory.

For query resolution, we generate a number of threads equals to the number of processors/cores of the machine, each of which repeatedly reads a line from the query file in mutual exclusion (with a spinlock, to reduce the number of context switches), runs the algorithm with time complexity between O(d) and O(n + m) (as proved in the GRAIL paper) and saves the result in an array, for later printing. Accessing the array of results is not mandated by any synchronization primitive, as every thread writes in a different portion of the array, and the reading is done by one thread, after all results have been generated.

## Experimental results

We conducted experimental runs of the final program and, while our setup is not compatible with the one presented in the GRAIL paper, our results are sometimes faster, sometimes slower, but in the same order of magnitude.
The graphs used during this step are the ones provided via the Portale della Didattica. For synthetic graphs, we used the query files generated by running the provided program. For real graphs, we generated 100000 random queries with the scripts `random_queries16b.sh` and `random_queries32b.sh`: both scripts accept an integer `a`, and generate queries, selecting nodes between 0 and `a - 1`. All experimental runs are reported in the file `stats.xslx`.
In particular:
- For synthetic graphs, we cannot compare our results with the one in the paper because our graphs have an average degree much larger than the ones used in the GRAIL paper.
- For small, sparse graphs, some of our results are between 1.5 and 10 times faster, while other are between 2 and 5 times slower. It is worth noting than the slower times are obteined from a different machine than the faster times.
- For small, dense graphs our results are around 2 times slower (we could only run arXiv with d > 5). Again, this slow results are obtained on the same slow machine mentioned above.
- For large, real graphs, our results are between 0% and 100% faster (we could not test uniprot-100m, because it stopped with a memory allocation error).

We can say that, for all graphs, the time for query resolution greatly drops with the increase of the number of labels (between 5 and 10 times faster), with a time for creating the index that rises between 50% and 400%, with a greater increase in smaller graphs.

## Conclusion

Our parallel implementation of the GRAIL algorithm shows great improvements in the speed of resolution of queries in large graphs with respect to the sequential implementation; the advantages of our parallel implementation are simple: we can generate each layer of the labels at the same time, and resolve more than one query at a time, which results in a lower execution time overall.